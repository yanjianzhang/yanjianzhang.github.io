<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta name="google-site-verification" content="EnW3iE5uXnkCt08dH5N1p2UztpHHWUslmyE_mIIGaac"><meta name="baidu-site-verification" content="code-EtTckMomHC"><meta charset="UTF-8"><title>CS APP malloclab</title><meta name="description" content="精诚致志，求仁存心"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="整体逻辑本项目实现堆的初始化，内存分配，内存释放以及内存的再分配。在内存分配的过程中，我使用了以下的策略匹配，并分别得出了下列分数。最终采用了显式空闲链表+首次适配+立即合并的策略匹配。

隐式空闲链表+首次适配+立即合并，util（51）+thru（1）=51，吞吐率很小，因为每次malloc的时候需要从头遍历所有的快，立即合并会发生抖动
隐式空闲链表+最佳适配+延迟合并，util（46）+thru（1）=46，
隐式空闲链表+最佳适配+立即合并，util（46）+thru（1）=46，后面两组数据很差
隐式空闲链表+首次适配+延迟合并，util（47）+thru（1）=47，
显式空闲链表+首次适配+立即合并，util(46)+thru(40)=86.对于堆的一致性检查，对于最小块的检查，并且打印  
.."><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Yanjian Zhang's Blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Yanjian Zhang's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">CS APP malloclab</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91"><span class="toc-text">整体逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%BA%8F%E8%A8%80%E5%BF%AB"><span class="toc-text">建立序言快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E5%A0%86"><span class="toc-text">拓展堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%9D%97"><span class="toc-text">合并块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%90%88%E9%80%82%E5%A0%86"><span class="toc-text">寻找合适堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-text">内存回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%86%8D%E5%88%86%E9%85%8D"><span class="toc-text">内存再分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#calloc-%E5%87%BD%E6%95%B0"><span class="toc-text">calloc 函数</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/ICS"><i class="tag post-item-tag">ICS</i></a><a href="/tags/CS%20APP"><i class="tag post-item-tag">CS APP</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">CS APP malloclab</h1><time class="has-text-grey" datetime="2018-08-14T11:58:02.000Z">2018-08-14</time><article class="mt-2 post-content"><h3 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h3><p>本项目实现堆的初始化，内存分配，内存释放以及内存的再分配。<br>在内存分配的过程中，我使用了以下的策略匹配，并分别得出了下列分数。最终采用了显式空闲链表+首次适配+立即合并的策略匹配。</p>
<ol>
<li>隐式空闲链表+首次适配+立即合并，util（51）+thru（1）=51，吞吐率很小，因为每次malloc的时候需要从头遍历所有的快，立即合并会发生抖动</li>
<li>隐式空闲链表+最佳适配+延迟合并，util（46）+thru（1）=46，</li>
<li>隐式空闲链表+最佳适配+立即合并，util（46）+thru（1）=46，后面两组数据很差</li>
<li>隐式空闲链表+首次适配+延迟合并，util（47）+thru（1）=47，</li>
<li>显式空闲链表+首次适配+立即合并，util(46)+thru(40)=86.<br>对于堆的一致性检查，对于最小块的检查，并且打印  </li>
</ol>
<pre><code class="lang-c">
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &quot;memlib.h&quot;
#include &quot;mm.h&quot;


//* Basic constants and macros: */
#define WSIZE      4              /* Word and header/footer size (bytes) */
#define DSIZE      8              /* Doubleword size (bytes) */
#define CHUNKSIZE  (1 &lt;&lt; 12)      /* Extend heap by this amount (bytes) */

/*Max value of 2 values*/
#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))

/* Pack a size and allocated bit into a word */
#define PACK(size, alloc)  ((size) | (alloc))

/* Read and write a word at address p. */
#define GET(p)       (*(uintptr_t *)(p))
#define PUT(p, val)  (*(uintptr_t *)(p) = (val))

/* Read the size and allocated fields from address p */
#define GET_SIZE(p)   (GET(p) &amp; ~(DSIZE - 1))
#define GET_ALLOC(p)  (GET(p) &amp; 0x1)


/* Given block ptr bp, compute address of its header and footer */
#define HDRP(bp)  ((void *)(bp) - WSIZE)
#define FTRP(bp)  ((void *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)

/* Given block ptr bp, compute address of next and previous blocks */
#define NEXT_BLK(bp)  ((void *)(bp) + GET_SIZE(HDRP(bp)))
#define PREV_BLK(bp)  ((void *)(bp) - GET_SIZE((void *)(bp) - DSIZE))

/* Given ptr in free list, get next and previous ptr in the list */
/* bp is address of the free block. Since minimum Block size is 16 bytes, 
   we utilize to store the address of previous block pointer and next block pointer.
*/
#define GET_NEXT_PTR(bp)  (*(char **)(bp + WSIZE))
#define GET_PREV_PTR(bp)  (*(char **)(bp))

/* Puts pointers in the next and previous elements of free list */
#define SET_NEXT_PTR(bp, qp) (GET_NEXT_PTR(bp) = qp)
#define SET_PREV_PTR(bp, qp) (GET_PREV_PTR(bp) = qp)

/* Global declarations */
static char *heap_listp = 0; 
static char *free_list_start = 0;

/* Function prototypes for internal helper routines */
static void *coalesce(void *bp);
static void *extend_heap(size_t words);
static void *find_fit(size_t asize);
static void place(void *bp, size_t asize);

/* Function prototypes for maintaining free list*/
static void insert_in_free_list(void *bp); 
static void remove_from_free_list(void *bp); 

/* Function prototypes for heap consistency checker routines: */
static void checkblock(void *bp);
static void checkheap(bool verbose);
static void printblock(void *bp); 
// void *calloc (size_t nmemb, size_t size);
</code></pre>
<h3 id="建立序言快"><a href="#建立序言快" class="headerlink" title="建立序言快"></a>建立序言快</h3><p>对内存进行创建，得到最初的空堆，建立序言块</p>
<pre><code class="lang-c">/** 
 * mm_init - 
 */
int mm_init(void) &#123;


  if ((heap_listp = mem_sbrk(8*WSIZE)) == NULL) 
    return -1;

  PUT(heap_listp, 0);                            /* 对齐填充 */
  PUT(heap_listp + (1 * WSIZE), PACK(DSIZE, 1)); /* 序章标题 */ 
  PUT(heap_listp + (2 * WSIZE), PACK(DSIZE, 1)); /* 页脚*/ 
  PUT(heap_listp + (3 * WSIZE), PACK(0, 1));     /* 结尾标题 */
  free_list_start = heap_listp + 2*WSIZE; 

 //链表中现在只有一个序言块
 //初始化堆空间4KB
  if (extend_heap(4) == NULL)&#123; 
    return -1;
  &#125;
  return 0;
&#125;
</code></pre>
<h3 id="拓展堆"><a href="#拓展堆" class="headerlink" title="拓展堆"></a>拓展堆</h3><p>用一个新的空块扩展堆，分配时保持对齐，并且设置块的头，同时与前一个块（如果有）合并</p>
<pre><code class="lang-c">
static void *extend_heap(size_t words) &#123;
  char *bp;
  size_t size;


  size = (words % 2) ? (words+1) * WSIZE : words * WSIZE;
  //最小块16字节，4字
  if (size &lt; 16)&#123;
    size = 16;
  &#125;
  /* call for more memory space */
  if ((int)(bp = mem_sbrk(size)) == -1)&#123; 
    return NULL;
  &#125;

  PUT(HDRP(bp), PACK(size, 0));         /* free block header */
  PUT(FTRP(bp), PACK(size, 0));         /* free block footer */
  PUT(HDRP(NEXT_BLK(bp)), PACK(0, 1)); /* 新的结尾标题 */
  /* 合并下一个和前一块bp */
  return coalesce(bp);
&#125;

/* 
 *在bp（地址）的开始处放置指定size的块
 */
static void place(void *bp, size_t asize)&#123;
  size_t csize = GET_SIZE(HDRP(bp));

  if ((csize - asize) &gt;= 4 * WSIZE) &#123;
    //如果剩余的大小（分配减去需求）大于最小块的大小，进行分割，剩余的快就会变成一个空闲块
    PUT(HDRP(bp), PACK(asize, 1));
    PUT(FTRP(bp), PACK(asize, 1));
    remove_from_free_list(bp);
    bp = NEXT_BLK(bp);
    //设置下一个快的属性，大小就是剩余块的大小
    PUT(HDRP(bp), PACK(csize-asize, 0));
    PUT(FTRP(bp), PACK(csize-asize, 0));
    coalesce(bp);
  &#125;
  else &#123;
    PUT(HDRP(bp), PACK(csize, 1));
    PUT(FTRP(bp), PACK(csize, 1));
    remove_from_free_list(bp);
  &#125;
&#125;
</code></pre>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>如果有可以分配的块就分配，否则就进行堆拓展，对比我们的初始化堆和需要分配的大小，向我们的堆空间申请额外的空间，进行堆拓展</p>
<pre><code class="lang-c">void *mm_malloc(size_t size) 
&#123;
  size_t asize;      /* 调整块大小 */
  size_t extendsize; /* 如果不合适，则扩展堆的数量*/
  void *bp;

  /* Ignore spurious requests. */
  if (size == 0)
    return (NULL);

  /* 调整块大小以包括开销和对齐请求 */
  if (size &lt;= DSIZE)
    asize = 2 * DSIZE;
  else
    asize = DSIZE * ((size + DSIZE + (DSIZE - 1)) / DSIZE);


  if ((bp = find_fit(asize)) != NULL) &#123;
    //如果找到可以分配的块就分配
    place(bp, asize);
    return (bp);
  &#125;

  //否则就进行堆拓展
  extendsize = MAX(asize, CHUNKSIZE);
  if ((bp = extend_heap(extendsize / WSIZE)) == NULL)  
    return (NULL);
  place(bp, asize);
  return (bp);
&#125;
</code></pre>
<h3 id="合并块"><a href="#合并块" class="headerlink" title="合并块"></a>合并块</h3><p>“bp” 是新释放的块的地址，合并边界标记，删除并插入空闲块指针到显示空闲列表，返回合并地址<br>先去检查前后是否有空闲块，并是否满足前后空闲块和当前已分配的空闲块size相加大于newsize，<br>如果是则合并，不需要再重新请求空闲块。<br>如果不行，则需要重新mm_malloc一块新的空间</p>
<pre><code class="lang-c">
static void *coalesce(void *bp)&#123;

  //读取大小和分配的字段，如果之前的被设置或者为0
  size_t NEXT_ALLOC = GET_ALLOC(  HDRP(NEXT_BLK(bp))  );
  size_t PREV_ALLOC = GET_ALLOC(  FTRP(PREV_BLK(bp))  ) || PREV_BLK(bp) == bp;
  size_t size = GET_SIZE(HDRP(bp));

  /* 下一块空闲，就将size加上下一块区域的大小，将下一个区域从空闲列表中移除*/   
  if (PREV_ALLOC &amp;&amp; !NEXT_ALLOC) &#123;                  
    size += GET_SIZE( HDRP(NEXT_BLK(bp))  );
    remove_from_free_list(NEXT_BLK(bp));
    PUT(HDRP(bp), PACK(size, 0));
    //此时加上size之后的foot已经变成了新的foot
    PUT(FTRP(bp), PACK(size, 0));
  &#125;
  /* 上一块空闲，就将size加上上一块区域的大小，将上一个区域从空闲列表中移除*/  
  else if (!PREV_ALLOC &amp;&amp; NEXT_ALLOC) &#123;               
    size += GET_SIZE( HDRP(PREV_BLK(bp))  );
    //添上前一个块的时候，bp的头要放到前一个块的位置
    bp = PREV_BLK(bp);
    remove_from_free_list(bp);
    PUT(HDRP(bp), PACK(size, 0));
    PUT(FTRP(bp), PACK(size, 0));
  &#125;
  /* 都空闲，就将size加上上一块区域和下一块区域的大小，将上下两区域从空闲列表中移除 */ 
  else if (!PREV_ALLOC &amp;&amp; !NEXT_ALLOC) &#123;                
    size += GET_SIZE( HDRP(PREV_BLK(bp))  ) + GET_SIZE( HDRP(NEXT_BLK(bp))  );
    remove_from_free_list(PREV_BLK(bp));
    remove_from_free_list(NEXT_BLK(bp));
    bp = PREV_BLK(bp);
    PUT(HDRP(bp), PACK(size, 0));
    PUT(FTRP(bp), PACK(size, 0));
  &#125;/* 最后将bp插入空闲列表并返回bp */
  insert_in_free_list(bp);
  return bp;
&#125;
</code></pre>
<h3 id="寻找合适堆"><a href="#寻找合适堆" class="headerlink" title="寻找合适堆"></a>寻找合适堆</h3><p>下面是对合适的堆的寻找，在列表中寻找合适大小的块，一直找到合适的就返回。如果相同的malloc请求连续进行了很多次大于40次，花费时间很长，直接把堆扩展到所需要的数量</p>
<pre><code class="lang-c">/*
 *下面是对合适的堆的寻找
 *在列表中寻找合适大小的块，一直找到合适的就返回
 *如果相同的malloc请求连续进行了很多次大于40次，花费时间很长，直接把堆扩展到所需要的数量
 *
 */

static void *find_fit(size_t asize)&#123;
  void *bp;
  static int last_malloced_size = 0;
  static int repeat_counter = 0;
  if( last_malloced_size == (int)asize)&#123;
      if(repeat_counter&gt;40)&#123;  
        int extendsize = MAX(asize, 4 * WSIZE);
        bp = extend_heap(extendsize/4);
        return bp;
      &#125;
      else
        repeat_counter++;
  &#125;
  else
    repeat_counter = 0;
  //在列表中寻找合适大小的块，一直找到合适的就返回
  for (bp = free_list_start; GET_ALLOC(HDRP(bp)) == 0; bp = GET_NEXT_PTR(bp) )&#123;
    if (asize &lt;= (size_t)GET_SIZE(HDRP(bp)) ) &#123;
      last_malloced_size = asize;
      return bp;
    &#125;
  &#125;
  return NULL;
&#125;
</code></pre>
<h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>回收我们的内存，有用有还</p>
<pre><code class="lang-c">
void mm_free(void *bp)&#123;
  size_t size;
  /* Ignore spurious requests. */
  if (bp == NULL)
    return;
  /* Free and coalesce the block. */
  size = GET_SIZE(HDRP(bp));
  PUT(HDRP(bp), PACK(size, 0));
  PUT(FTRP(bp), PACK(size, 0));
  coalesce(bp);
&#125;
</code></pre>
<h3 id="内存再分配"><a href="#内存再分配" class="headerlink" title="内存再分配"></a>内存再分配</h3><p>以下是内存的再分配，参数bp是分配的块或者null;</p>
<ol>
<li>如果大小为0,则释放块bp，并且返回null</li>
<li>请求的size小于旧的块，那么返回bp</li>
<li>当大于，如果下一块恰好是空的，那么和当前的合并;此时不需要malloc，只需调整他们的大小</li>
<li><p>如果没有，那么malloc一个新的块，bp被复制到这个新的块，返回这个地址</p>
<pre><code class="lang-c">void *mm_realloc(void *bp, size_t size)&#123;
if((int)size &lt; 0) 
 return NULL; 
else if((int)size == 0)&#123; 
 mm_free(bp); 
 return NULL; 
&#125; 
else if(size &gt; 0)&#123; 
   size_t oldsize = GET_SIZE(HDRP(bp)); 
   size_t newsize = size + 2 * WSIZE; // 页眉和页脚的2个字
   /*如果小于 */
   if(newsize &lt;= oldsize)&#123; 
       return bp; 
   &#125;
   /*如果大于*/ 
   else &#123; 
       size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLK(bp))); 
       size_t csize;
       /* 如果下一块空闲，并且大小&gt;=新的*/ 
       if(!next_alloc &amp;&amp; ((csize = oldsize + GET_SIZE(  HDRP(NEXT_BLK(bp))  ))) &gt;= newsize)&#123; 
         remove_from_free_list(NEXT_BLK(bp)); 
         PUT(HDRP(bp), PACK(csize, 1)); 
         PUT(FTRP(bp), PACK(csize, 1)); 
         return bp; 
       &#125;
       else &#123;  
         void *new_ptr = mm_malloc(newsize);  
         place(new_ptr, newsize);
         memcpy(new_ptr, bp, newsize); 
         mm_free(bp); 
         return new_ptr; 
       &#125; 
   &#125;
&#125;else 
 return NULL;
&#125;
</code></pre>
<h3 id="calloc-函数"><a href="#calloc-函数" class="headerlink" title="calloc 函数"></a>calloc 函数</h3><p>以下是calloc的实现，calloc相当于size个nmenb的内存分配<br>```c<br>void <em>mm_calloc (size_t nmemb, size_t size)<br>{<br> size_t bytes = nmemb </em> size;<br> void *newptr;</p>
<p> newptr = mm_malloc(bytes);<br> memset(newptr, 0, bytes);</p>
<p> return newptr;<br>}</p>
</li>
</ol>
<pre><code>### 其他
```c
/*将空闲指针插入free_list*/
static void insert_in_free_list(void *bp)&#123;
  SET_NEXT_PTR(bp, free_list_start); 
  SET_PREV_PTR(free_list_start, bp); 
  SET_PREV_PTR(bp, NULL); 
  free_list_start = bp; 
&#125;
/*删除空闲指针*/
static void remove_from_free_list(void *bp)&#123;
  if (GET_PREV_PTR(bp))
    SET_NEXT_PTR(GET_PREV_PTR(bp), GET_NEXT_PTR(bp));
  else
    free_list_start = GET_NEXT_PTR(bp);
  SET_PREV_PTR(GET_NEXT_PTR(bp), GET_PREV_PTR(bp));
&#125;

/*
 *对块bp进行最小块的检查
 */
static void checkblock(void *bp) 
&#123;

  if ((uintptr_t)bp % DSIZE)
    printf(&quot;Error: %p不是双字对齐的\n&quot;, bp);
  if (GET(HDRP(bp)) != GET(FTRP(bp)))
    printf(&quot;Error: 标题不匹配页脚\n&quot;);
&#125;

/* 
 *对最小堆的一致性检查
 */
void checkheap(bool verbose) 
&#123;
  void *bp;

  if (verbose)
    printf(&quot;Heap (%p):\n&quot;, heap_listp);

  if (GET_SIZE(HDRP(heap_listp)) != DSIZE ||
      !GET_ALLOC(HDRP(heap_listp)))
    printf(&quot;错的序幕标题\n&quot;);
  checkblock(heap_listp);

  for (bp = heap_listp; GET_SIZE(HDRP(bp)) &gt; 0; bp = (void *)NEXT_BLK(bp)) &#123;
    if (verbose)
      printblock(bp);
    checkblock(bp);
  &#125;

  if (verbose)
    printblock(bp);
  if (GET_SIZE(HDRP(bp)) != 0 || !GET_ALLOC(HDRP(bp)))
    printf(&quot;错的结尾标题\n&quot;);
&#125;

/*
 *打印块bp
 */
static void printblock(void *bp) 
&#123;
  bool halloc, falloc;
  size_t hsize, fsize;

  checkheap(false);
  hsize = GET_SIZE(HDRP(bp));
  halloc = GET_ALLOC(HDRP(bp));  
  fsize = GET_SIZE(FTRP(bp));
  falloc = GET_ALLOC(FTRP(bp));  

  if (hsize == 0) &#123;
    printf(&quot;%p: end of heap\n&quot;, bp);
    return;
  &#125;

  printf(&quot;%p: header: [%zu:%c] footer: [%zu:%c]\n&quot;, bp, 
      hsize, (halloc ? &#39;a&#39; : &#39;f&#39;), 
      fsize, (falloc ? &#39;a&#39; : &#39;f&#39;));
&#125;
</code></pre></article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2018/08/23/Vueform/" title="Vue项目v-for、v-model的使用"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Vue项目v-for、v-model的使用</span></a><a class="button is-default" href="/2018/08/14/proxylab/" title="CS APP proxylab"><span class="has-text-weight-semibold">Next: CS APP proxylab</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/yanjianzhang"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/zhangyanjian"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><a title="linkedin" target="_blank" rel="noopener nofollow" href="//www.linkedin.com/in/yanjianzhang"><i class="iconfont icon-linkedin"></i></a><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/zhang.yanjian.7"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Yanjian Zhang 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>