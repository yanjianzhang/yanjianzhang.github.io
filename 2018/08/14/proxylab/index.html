<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta name="google-site-verification" content="EnW3iE5uXnkCt08dH5N1p2UztpHHWUslmyE_mIIGaac"><meta name="baidu-site-verification" content="code-EtTckMomHC"><meta charset="UTF-8"><title>CS APP proxylab</title><meta name="description" content="精诚致志，求仁存心"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="本项目要求实现一个代理服务器，从服务器拿到消息，发回给客户端，主要涉及一个读写上的竞争问题，本人使用信号量来解决。
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;
#include &amp;quot;csapp.h&amp;quot;

/* Recommended max cache and object sizes */
#define MAX_CACHE_SIZE 1049000
#define MAX_OBJECT_SIZE 102400

/* You won&amp;#39;t lose style points for including this long line in your code */
static const char *user_agent_hd.."><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Yanjian Zhang's Blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Yanjian Zhang's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">CS APP proxylab</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile is-hidden"></div><div class="column is-9"><header class="my-4"><a href="/tags/ICS"><i class="tag post-item-tag">ICS</i></a><a href="/tags/CS%20APP"><i class="tag post-item-tag">CS APP</i></a><a href="/tags/proxy"><i class="tag post-item-tag">proxy</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">CS APP proxylab</h1><time class="has-text-grey" datetime="2018-08-14T11:56:02.000Z">2018-08-14</time><article class="mt-2 post-content"><p>本项目要求实现一个代理服务器，从服务器拿到消息，发回给客户端，主要涉及一个读写上的竞争问题，本人使用信号量来解决。</p>
<pre><code class="lang-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &quot;csapp.h&quot;

/* Recommended max cache and object sizes */
#define MAX_CACHE_SIZE 1049000
#define MAX_OBJECT_SIZE 102400

/* You won&#39;t lose style points for including this long line in your code */
static const char *user_agent_hdr = &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;;
static const char *connect_hdr = &quot;Connection: close\r\n&quot;;
static const char *proxy_hdr = &quot;Proxy-Connection: close\r\n&quot;;

static const char *connection_key = &quot;Connection&quot;;
static const char *user_agent_key= &quot;User-Agent&quot;;
static const char *proxy_connection_key = &quot;Proxy-Connection&quot;;
static const char *host_key = &quot;Host&quot;;

#define EOF_TYPE 1
#define HOST_TYPE 2
#define OTHER_TYPE 3
#define CACHE_NUM 10

int getType(char *buf);
void doit(int connfd);
void parseUri(char uri[],char hostname[],char path[],char port[]);
void build_http
(char *server_http,char *hostname,char*path,char* port,rio_t *clientrio);
void* thread(void *vargp);
void initCache();
void PreRead(int index);
void afterRead(int index);
void preWrite(int index);
void afterWrite(int index);
int findCache(char *url);
void updateLRU(int index);
int findSuitCache();
void writeCacheContent(char *url,char* buf);

//dongfanker 端口号50712
//这是文件的cache单元数据结构
typedef struct 
&#123;
    char content[MAX_OBJECT_SIZE];
    char url[MAXLINE];
    int time;
    int isEmpty;
    int readCount;
    int writeCount;
    sem_t mutex;
    sem_t w;
&#125;cacheunit;
//cache由10个cache的数据单元构成
typedef struct 
&#123;
    cacheunit cacheUnit[CACHE_NUM];
&#125;Cache;

Cache cache;
//记录更新cache单元的次数
int allTime=0;
//定义用作消除竞争的flag
sem_t flag;

//首先获得端口号，用open_listenfd函数打开对套接子的监听之后，就无线循环，处理连接请求，执行请求，关闭链接它的另一端
int main(int argc,char **argv)
&#123;
    int listenfd,*connfd;
    char hostname[MAXLINE],port[MAXLINE];
    socklen_t clientlen;
    struct  sockaddr_storage clientaddr;
    pthread_t tid;
    Signal(SIGPIPE, SIG_IGN);
    Sem_init(&amp;flag,0,1);
    // the cmd parameters fail
    if (argc!=2)&#123;
        fprintf(stderr, &quot;usage: %s &lt;port&gt;\n&quot;,argv[0]);
        exit(1);
    &#125;
    initCache();
    listenfd= open_listenfd(argv[1]);
    while (1)
    &#123;
        clientlen=sizeof(clientaddr);
        connfd=malloc(sizeof(int));
    //建立之后用于多线程的
        *connfd=Accept(listenfd,(SA*)&amp;clientaddr,&amp;clientlen);
        Getnameinfo((SA*)&amp;clientaddr,clientlen,hostname,MAXLINE,
                    port,MAXLINE,0);
        printf(&quot;Accepted connection from (%s , %s)\n&quot;,hostname,port);
        Pthread_create(&amp;tid,NULL,thread,(void*)connfd);
    &#125;
&#125;

//thread函数是在main函数中用作创建和处理线程的函数
void *thread(void *vargo)
&#123;
    int connfd = *((int *)vargo);
    Pthread_detach(pthread_self());
    free(vargo);
    doit(connfd);
    Close(connfd);
    return NULL;
&#125;



//do it函数是thread函数中的处理函数
void doit(int connfd)
&#123;
    int serverFd;
    rio_t clientrio,serverrio;
    char server_http[MAXLINE],buf[MAXLINE],method[MAXLINE],path[MAXLINE];
    char port[MAXLINE],uri[MAXLINE],version[MAXLINE],hostname[MAXLINE];

    // P(&amp;flag);
    //     allTime+=1;
    // V(&amp;flag);
    //首先获取一个request链接
    rio_readinitb(&amp;clientrio,connfd);
    rio_readlineb(&amp;clientrio,buf,MAXLINE);
    sscanf(buf,&quot;%s %s %s&quot;,method,uri,version);
    //对请求行进行处理，如果请求的方法不是GET的话，就告诉它我没有实现对这个方法的处理。
    if (strcasecmp(method,&quot;GET&quot;))&#123;
        printf(&quot;Proxy does not implement this method&quot;);
        return;
    &#125;

    int cacheIndex;
    if ((cacheIndex=findCache(uri))&gt;0)
    &#123;
        PreRead(cacheIndex);
        rio_writen(connfd,cache.cacheUnit[cacheIndex].content,
            strlen(cache.cacheUnit[cacheIndex].content));
        printf(&quot;the proxy has received %lu bytes\n&quot;,
            strlen(cache.cacheUnit[cacheIndex].content));
        afterRead(cacheIndex);
        updateLRU(cacheIndex);
    &#125;
    //然后就对uri进行解析，获得服务器主机名、文件地址以及端口浩
    parseUri(uri,hostname,path,port);
    //构建新的请求头
    build_http(server_http,hostname,path,port,&amp;clientrio);
    //与服务器端进行链接
    serverFd=open_clientfd(hostname,port);
    if (serverFd&lt;0)&#123;
        printf(&quot;connection failed\n&quot;);
        return;
    &#125;
    rio_readinitb(&amp;serverrio,serverFd);
    //将请求头写入传送给服务器
    rio_writen(serverFd,server_http,strlen(server_http));

    size_t len;
    size_t allCount=0;
    char cacheBuf[MAX_OBJECT_SIZE];
    //从服务器拿到消息，发回给客户端
    while ((len=rio_readlineb(&amp;serverrio,buf,MAXLINE))!=0)
    &#123;
        allCount+=len;
        if (allCount&lt;MAX_OBJECT_SIZE)
            strcat(cacheBuf,buf);
        rio_writen(connfd,buf,len);
    &#125;
    printf(&quot;the proxy has received %lu bytes\n&quot;,allCount);
    Close(serverFd);
    //当字节数低于
    if (allCount&lt;MAX_OBJECT_SIZE)
        writeCacheContent(uri,cacheBuf);
&#125;

//利用LRU（最近使用）的原则找到合适的Cache来用于写
int findSuitCache()
&#123;
    int i,result=-1,minTime=0x7fffffff;
    for (i=0;i&lt;CACHE_NUM;++i)&#123;
        PreRead(i);
        if (cache.cacheUnit[i].isEmpty)&#123;
            result=i;
        &#125;
        afterRead(i);
        if (result==i)
            break;
    &#125;
    if (result!=-1)
        return result;
    for (i=0;i&lt;CACHE_NUM;++i)&#123;
        PreRead(i);
        if (cache.cacheUnit[i].time&lt;minTime)&#123;
            minTime=cache.cacheUnit[i].time;
            result=i;
        &#125;
        afterRead(i);
    &#125;
    return result;
&#125;

//这是do it里面的写cache的操作，用来调用上面定义的找到合适的cache1的findSuitCache函数，找到Cache来进行书写
void writeCacheContent(char *url,char* buf)
&#123;
    int index = findSuitCache();
    preWrite(index);
    strcpy(cache.cacheUnit[index].content,buf);
    strcpy(cache.cacheUnit[index].url,url);
    cache.cacheUnit[index].isEmpty=0;
    afterWrite(index);
    updateLRU(index);
&#125;


/*此处构建新的请求头，Host、User-Agent、Connection、Proxy-Connection
  等key的value部分修改为指定的信息，其他的保持不变*/
void build_http
(char *server_http,char *hostname,char*path,char* port,rio_t *clientrio)
&#123;
    char requestLine[MAXLINE],buf[MAXLINE];
    char host_hdr[MAXLINE],other_hdr[MAXLINE];
    //获得请求服务的正确字符串
    sprintf(requestLine,&quot;GET %s HTTP/1.0\r\n&quot;,path);
    while (rio_readlineb(clientrio,buf,MAXLINE)&gt;0)
    &#123;
        int type = getType(buf);
        if (type==EOF_TYPE)
            break;
        else if (type==HOST_TYPE)&#123;
            strcpy(host_hdr,buf);
        &#125;
        else&#123;
            strcat(other_hdr,buf);
        &#125;
    &#125;
    if (strlen(host_hdr)==0)
        sprintf(host_hdr,&quot;Host: %s\r\n&quot;,hostname);
    sprintf(server_http,&quot;%s%s%s%s%s%s\r\n&quot;,
            requestLine,
            host_hdr,
            connect_hdr,
            proxy_hdr,
            user_agent_hdr,
            other_hdr);
    return;
&#125;


//这个是在build_http函数中进行字符串比较的getType函数
int getType(char *buf)
&#123;
    if(strcmp(buf,&quot;\r\n&quot;)==0)
        return EOF_TYPE;
    else if (!strncasecmp(buf,host_key,strlen(host_key)))
        return HOST_TYPE;
    else if (strncasecmp(buf,connection_key,strlen(connection_key))
             &amp;&amp;strncasecmp(buf,proxy_connection_key,strlen(proxy_connection_key))
             &amp;&amp;strncasecmp(buf,user_agent_key,strlen(user_agent_key)))
        return OTHER_TYPE;
    return 0;
&#125;

//这是doit函数中对于uri的解析
void parseUri(char uri[],char hostname[],char path[],char port[])
&#123;
    //从URI中获取服务器名字
    int i=0;
    char* hostnamePos=strstr(uri,&quot;//&quot;);
    if (hostnamePos!=NULL)
        hostnamePos+=2;
    else
        hostnamePos=uri;
    strcpy(hostname,hostnamePos);
    int len=strlen(hostname);
    for (i=0;i&lt;len;++i)&#123;
        if (hostname[i]==&#39;/&#39;||hostname[i]==&#39;:&#39;)&#123;
            hostname[i]=&#39;\0&#39;;
            break;
        &#125;
    &#125;

    //从uri中获取端口号
    char* portPos=strchr(hostnamePos,&#39;:&#39;);
    if (portPos!=NULL)&#123;
        strcpy(port,portPos+1);
        len=strlen(port);
        for (i=0;i&lt;len;++i)&#123;
            if (!isdigit(port[i]))&#123;
                port[i]=&#39;\0&#39;;
                break;
            &#125;
        &#125;
    &#125;
    else&#123;
        port[0]=&#39;8&#39;;port[1]=&#39;0&#39;;port[2]=&#39;\0&#39;;
    &#125;

    //从uri中获取路径
    char *pathPos=strstr(uri,&quot;//&quot;);
    if (pathPos!=NULL)
        pathPos+=2;
    else
        pathPos=uri;
    pathPos=strchr(pathPos,&#39;/&#39;);
    strcpy(path,pathPos);
    char *endpos = strchr(path,&#39;:&#39;);
    if (endpos!=NULL)&#123;
        (*endpos)=&#39;\0&#39;;
    &#125;
    printf(&quot;hostname:%s\npath:%s\nport:%s\n&quot;,hostname,path,port);
    return;
&#125;


//这是main函数中用来初始化Cache函数
void initCache()
&#123;
    int i = 0;
    for (i = 0; i &lt; 10; ++i)
    &#123;
        cache.cacheUnit[i].isEmpty=1;
        cache.cacheUnit[i].time=0;
        Sem_init(&amp;cache.cacheUnit[i].mutex,0,1);
        Sem_init(&amp;cache.cacheUnit[i].w,0,1);
        cache.cacheUnit[i].readCount=0;
        cache.cacheUnit[i].writeCount=0;
    &#125;
&#125;

//关键问题，使用信号量来限制程序的执行顺序。计数信号量具备两种操作动作，称为 V（又称signal()）与 P（wait()）
// 一下四个函数用于Cache的加锁与解锁
// 用以解决竞争问题

/*运行 P，信号量 S 的值将被减少。倘若进程企图进入临界区块的，需要先运行 P。当信号量 S 减为负值时，进程会被挡住
，不能继续；当信号量S不为负值时，进程可以获准进入临界区块  */
void PreRead(int index)
&#123;
    P(&amp;cache.cacheUnit[index].mutex);
    cache.cacheUnit[index].readCount++;
    if (cache.cacheUnit[index].readCount==1)
        P(&amp;cache.cacheUnit[index].w);
    V(&amp;cache.cacheUnit[index].mutex);
&#125;
//运行 V，信号量 S 的值会被增加。倘若进程想要结束离开临界区块，将会运行 V。当信号量 S 不为负值时，先前被挡住的其他进程，将可获准进入临界区块。

void afterRead(int index)
&#123;
    P(&amp;cache.cacheUnit[index].mutex);
    cache.cacheUnit[index].readCount--;
    if (cache.cacheUnit[index].readCount==0)
        V(&amp;cache.cacheUnit[index].w);
    V(&amp;cache.cacheUnit[index].mutex);
&#125;

void preWrite(int index)
&#123;
    P(&amp;cache.cacheUnit[index].w);
&#125;

void afterWrite(int index)
&#123;
    V(&amp;cache.cacheUnit[index].w);
&#125;

int findCache(char *url)
&#123;
    int i,result=-1;
    for (i=0;i&lt;CACHE_NUM;++i)&#123;
        PreRead(i);
        if ((cache.cacheUnit[i].isEmpty==0)&amp;&amp;
            strcmp(cache.cacheUnit[i].url,url)==0)
            result=i;
        afterRead(i);
    &#125;
    return result;
&#125;

//update the read/write cache&#39;s visit time 
void updateLRU(int index)
&#123;
    preWrite(index);
    cache.cacheUnit[index].time=allTime;
    afterWrite(index);
&#125;
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2018/08/14/malloclab/" title="CS APP malloclab"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: CS APP malloclab</span></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><script src="/js/post.js"></script></body></html>