<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta name="google-site-verification" content="EnW3iE5uXnkCt08dH5N1p2UztpHHWUslmyE_mIIGaac"><meta name="baidu-site-verification" content="code-EtTckMomHC"><meta charset="UTF-8"><title>Hackerrank Dicts 解题记录</title><meta name="description" content="精诚致志，求仁存心"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="Hash Tables: Ransom Note一道简易的题目，由于碰到了我经常用到的库 Counter，所以在此还是记录一下

from collections import Counter

def checkMagazine(magazine, note):
    magazineList =  Counter(magazine)
    magazineDict = &amp;#123;v:magazineList[v] for v in magazineList&amp;#125;
    noteList = Counter(note)
    noteDict = &amp;#123;v:noteList[v] for v in noteList&amp;#125;
    for v in noteDict:
     .."><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Yanjian Zhang's Blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Yanjian Zhang's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Hackerrank Dicts 解题记录</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-Tables-Ransom-Note"><span class="toc-text">Hash Tables: Ransom Note</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sherlock-and-Anagrams"><span class="toc-text">Sherlock and Anagrams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Count-Triplets"><span class="toc-text">Count Triplets</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/hackerrank"><i class="tag post-item-tag">hackerrank</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Hackerrank Dicts 解题记录</h1><time class="has-text-grey" datetime="2018-08-31T00:44:02.000Z">2018-08-31</time><article class="mt-2 post-content"><h3 id="Hash-Tables-Ransom-Note"><a href="#Hash-Tables-Ransom-Note" class="headerlink" title="Hash Tables: Ransom Note"></a><a target="_blank" rel="noopener" href="https://www.hackerrank.com/challenges/ctci-ransom-note">Hash Tables: Ransom Note</a></h3><p>一道简易的题目，由于碰到了我经常用到的库 Counter，所以在此还是记录一下</p>
<pre><code class="lang-python">
from collections import Counter

def checkMagazine(magazine, note):
    magazineList =  Counter(magazine)
    magazineDict = &#123;v:magazineList[v] for v in magazineList&#125;
    noteList = Counter(note)
    noteDict = &#123;v:noteList[v] for v in noteList&#125;
    for v in noteDict:
        if v not in magazineDict or magazineDict[v] &lt; noteDict[v]:
            print(&quot;No&quot;)
            return
    print(&quot;Yes&quot;)
    return
</code></pre>
<p>对比一下其他人使用相同的库的代码，感觉别人写的实在是太骚了呀，深深感觉到自己的掌握还远远不够</p>
<pre><code class="lang-python">def checkMagazine(magazine, note):
    if not (Counter(note) - Counter(magazine)):
    # or Counter(note) - Counter(magazine) == &#123;&#125;
        print(&quot;Yes&quot;)
    else:
        print(&quot;No&quot;)
</code></pre>
<hr>
<h3 id="Sherlock-and-Anagrams"><a href="#Sherlock-and-Anagrams" class="headerlink" title="Sherlock and Anagrams"></a><a target="_blank" rel="noopener" href="https://www.hackerrank.com/challenges/sherlock-and-anagrams">Sherlock and Anagrams</a></h3><p>一道中等难度的题目,最初采用将字符串都拆解成他们的不同字串的方法，结果超时了，想想也是，如果是100个字母长度的字符串，那么结果就是2<sup>100</sup>,不超时才怪。</p>
<pre><code class="lang-python">from collections import Counter

def checkAnag(a,b):
    if Counter(a) == Counter(b):
        return True

def sherlockAndAnagrams(s):
    count = 0
    s1 = &quot;&quot;.join(reversed(s))
    sub1 =[s1[i:i+x+1] for i in range(len(s1)) for x in range(len(s1)-i)]
    if s1 in sub1:
        sub1.remove(s1)
    for i in range(len(sub1)):
        for j in range(i+1,len(sub1)):
            if checkAnag(sub1[i],sub1[j]):
                count += 1
    return count
</code></pre>
<p>与其对其中的每一个字母进行计数，还不如将所有的字母都按顺序排列一遍，然后再比较最后的两个序列是否相同，此思路的实现代码如下</p>
<pre><code class="lang-python">def sherlockAndAnagrams(s):
    count=0
    dict=&#123;&#125;
    n=len(s)
    for i in range(n):
        for j in range(n-i):
            sub=&#39;&#39;.join(sorted(s[j:j+i+1]))
            try:
                dict[sub]+=1
            except:
                dict[sub]=1
    for i in dict:
        count+=dict[i]*(dict[i]-1)//2
    return count
</code></pre>
<hr>
<h3 id="Count-Triplets"><a href="#Count-Triplets" class="headerlink" title="Count Triplets"></a><a target="_blank" rel="noopener" href="https://www.hackerrank.com/challenges/count-triplets-1">Count Triplets</a></h3><p>对三个数进行r倍组合，1为特殊情况，我直接用了组合计算，不过代码出现了超时，再研究研究哪里出了问题</p>
<pre><code class="lang-python">from collections import Counter
from itertools import combinations
# Complete the countTriplets function below.
def combinationResult(num):
    i = 0
    for combination in combinations(range(num),3):
        i += 1
    return i 
def countTriplets(arr, r):
    sum = 0
    square = r**2
    countNum = Counter(arr)
    if r == 1:
        for v in countNum:
            if(countNum[v]&gt;2):
                sum += combinationResult(countNum[v])
        return sum
    sortSet = list(sorted(set(arr)))
    firstLimit = sortSet[len(sortSet)-1]/square
    for x in sortSet:
        if x &gt; firstLimit:
            break
        if x*r in sortSet and x*square in sortSet:
            sum += countNum[x]*countNum[x*r]*countNum[x*square]

    return sum
</code></pre>
<p>关于组合数的计算，参见<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41947081/article/details/80740756">python计算组合数的两种实现方法</a><br>经过对两种方法(直接进行组合与笛卡尔乘积)的比对，得出直接利用combinations来计算更加迅速一些,以下为比较代码：</p>
<pre><code class="lang-python">import math
import itertools
import time
from itertools import combinations

unique = [1, 2, 3, 4, 5, 56, 78, 23]
time1 = time.time()
for j in range(1000000):
    i = 0
    for combination in combinations(unique, 2):
        i += 1

time2 = time.time()

for j in range(1000000):
    d = 0
    uniques = [unique, unique]
    for combination in itertools.product(*uniques):
        d += 1
time3 = time.time()
print(&quot;time 2-1 = &quot;+str(time2-time1), &quot;time 3-1 = &quot;+str(time3-time2))
#time 2-1 = 3.7130393981933594 time 3-1 = 7.952743053436279
</code></pre>
<p>为了将这道题解决，我看了一下出题者的解释，在出题者的hint中提到本题是能够达到O(n)的复杂度的，反观一下自己，虽然自己并没有写什么循环，不过的话在循环里的if语句中用到了两个in，基本算是O(n<sup>3</sup>)的复杂度了。<br>按照作者的意思，作者进行个对arr的遍历，建立两个字典，假设三元组为(A，B，C)，两个字典分别是指对于B来说A已经存在了，以及对于C来说（A，B）的组合已经准备好了。<br>每个字典里面放的并不是实值，而是对于未来三元组的一个可能性的预测，在遍历每个A的同时让B与C的线性空间不断减小，是一个非常有意思的解决思路。以下是它的python代码。</p>
<pre><code class="lang-python">def countTriplets(arr, r):
    r2 = Counter()
    r3 = Counter()
    count = 0

    for v in arr:
        if v in r3:
            count += r3[v]

        if v in r2:
            r3[v*r] += r2[v]

        r2[v*r] += 1

    return count
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2018/09/01/Vue-route-pamas/" title="Vue项目路由传参"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Vue项目路由传参</span></a><a class="button is-default" href="/2018/08/30/list_hr/" title="Hackerrank Arrays 解题记录"><span class="has-text-weight-semibold">Next: Hackerrank Arrays 解题记录</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/dongfanker"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/zhangyanjian"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><a title="linkedin" target="_blank" rel="noopener nofollow" href="//www.linkedin.com/in/yanjian-zhang-154975154"><i class="iconfont icon-linkedin"></i></a><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/zhang.yanjian.7"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Yanjian Zhang 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>