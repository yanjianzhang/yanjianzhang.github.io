<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta name="google-site-verification" content="EnW3iE5uXnkCt08dH5N1p2UztpHHWUslmyE_mIIGaac"><meta name="baidu-site-verification" content="code-EtTckMomHC"><meta charset="UTF-8"><title>Hackerrank Dicts 解题记录</title><meta name="description" content="精诚致志，求仁存心"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="Hash Tables: Ransom Note一道简易的题目，由于碰到了我经常用到的库 Counter，所以在此还是记录一下

from collections import Counter

def checkMagazine(magazine, note):
    magazineList =  Counter(magazine)
    magazineDict = &amp;#123;v:magazineList[v] for v in magazineList&amp;#125;
    noteList = Counter(note)
    noteDict = &amp;#123;v:noteList[v] for v in noteList&amp;#125;
    for v in noteDict:
     .."><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Yanjian Zhang's Blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Yanjian Zhang's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Hackerrank Dicts 解题记录</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-Tables-Ransom-Note"><span class="toc-text">Hash Tables: Ransom Note</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E4%B8%80%E4%B8%8B%E5%85%B6%E4%BB%96%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E7%9A%84%E5%BA%93%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%84%9F%E8%A7%89%E5%88%AB%E4%BA%BA%E5%86%99%E7%9A%84%E5%AE%9E%E5%9C%A8%E6%98%AF%E5%A4%AA%E9%AA%9A%E4%BA%86%E5%91%80%EF%BC%8C%E6%B7%B1%E6%B7%B1%E6%84%9F%E8%A7%89%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%8E%8C%E6%8F%A1%E8%BF%98%E8%BF%9C%E8%BF%9C%E4%B8%8D%E5%A4%9Fpython-def-checkMagazine-magazine-note-if-not-Counter-note-Counter-magazine-or-Counter-note-Counter-magazine-print-quot-Yes-quot-else-print-quot-No-quot"><span class="toc-text">对比一下其他人使用相同的库的代码，感觉别人写的实在是太骚了呀，深深感觉到自己的掌握还远远不够python def checkMagazine(magazine, note):     if not (Counter(note) - Counter(magazine)):     # or Counter(note) - Counter(magazine) &#x3D;&#x3D; {}         print(&quot;Yes&quot;)     else:         print(&quot;No&quot;) </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sherlock-and-Anagrams"><span class="toc-text">Sherlock and Anagrams</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E5%AF%B9%E5%85%B6%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AF%8D%E8%BF%9B%E8%A1%8C%E8%AE%A1%E6%95%B0%EF%BC%8C%E8%BF%98%E4%B8%8D%E5%A6%82%E5%B0%86%E6%89%80%E6%9C%89%E7%9A%84%E5%AD%97%E6%AF%8D%E9%83%BD%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E4%B8%80%E9%81%8D%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E6%AF%94%E8%BE%83%E6%9C%80%E5%90%8E%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%BA%8F%E5%88%97%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C%EF%BC%8C%E6%AD%A4%E6%80%9D%E8%B7%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8Bpython-def-sherlockAndAnagrams-s-count-0-dict-n-len-s-for-i-in-range-n-for-j-in-range-n-i-sub-39-39-join-sorted-s-j-j-i-1-try-dict-sub-1-except-dict-sub-1-for-i-in-dict-count-dict-i-dict-i-1-2-return-count"><span class="toc-text">与其对其中的每一个字母进行计数，还不如将所有的字母都按顺序排列一遍，然后再比较最后的两个序列是否相同，此思路的实现代码如下python def sherlockAndAnagrams(s):     count&#x3D;0     dict&#x3D;{}     n&#x3D;len(s)     for i in range(n):         for j in range(n-i):             sub&#x3D;&#39;&#39;.join(sorted(s[j:j+i+1]))             try:                 dict[sub]+&#x3D;1             except:                 dict[sub]&#x3D;1     for i in dict:         count+&#x3D;dict[i]*(dict[i]-1)&#x2F;&#x2F;2     return count </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Count-Triplets"><span class="toc-text">Count Triplets</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/hackerrank"><i class="tag post-item-tag">hackerrank</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Hackerrank Dicts 解题记录</h1><time class="has-text-grey" datetime="2018-08-31T00:44:02.000Z">2018-08-31</time><article class="mt-2 post-content"><h3 id="Hash-Tables-Ransom-Note"><a href="#Hash-Tables-Ransom-Note" class="headerlink" title="Hash Tables: Ransom Note"></a><a target="_blank" rel="noopener" href="https://www.hackerrank.com/challenges/ctci-ransom-note">Hash Tables: Ransom Note</a></h3><p>一道简易的题目，由于碰到了我经常用到的库 Counter，所以在此还是记录一下</p>
<pre><code class="python">
from collections import Counter

def checkMagazine(magazine, note):
    magazineList =  Counter(magazine)
    magazineDict = &#123;v:magazineList[v] for v in magazineList&#125;
    noteList = Counter(note)
    noteDict = &#123;v:noteList[v] for v in noteList&#125;
    for v in noteDict:
        if v not in magazineDict or magazineDict[v] &lt; noteDict[v]:
            print(&quot;No&quot;)
            return
    print(&quot;Yes&quot;)
    return
</code></pre>
<h2 id="对比一下其他人使用相同的库的代码，感觉别人写的实在是太骚了呀，深深感觉到自己的掌握还远远不够python-def-checkMagazine-magazine-note-if-not-Counter-note-Counter-magazine-or-Counter-note-Counter-magazine-print-quot-Yes-quot-else-print-quot-No-quot"><a href="#对比一下其他人使用相同的库的代码，感觉别人写的实在是太骚了呀，深深感觉到自己的掌握还远远不够python-def-checkMagazine-magazine-note-if-not-Counter-note-Counter-magazine-or-Counter-note-Counter-magazine-print-quot-Yes-quot-else-print-quot-No-quot" class="headerlink" title="对比一下其他人使用相同的库的代码，感觉别人写的实在是太骚了呀，深深感觉到自己的掌握还远远不够python def checkMagazine(magazine, note):     if not (Counter(note) - Counter(magazine)):     # or Counter(note) - Counter(magazine) == {}         print(&quot;Yes&quot;)     else:         print(&quot;No&quot;) "></a>对比一下其他人使用相同的库的代码，感觉别人写的实在是太骚了呀，深深感觉到自己的掌握还远远不够<br><code>python def checkMagazine(magazine, note):     if not (Counter(note) - Counter(magazine)):     # or Counter(note) - Counter(magazine) == &#123;&#125;         print(&quot;Yes&quot;)     else:         print(&quot;No&quot;) </code></h2><h3 id="Sherlock-and-Anagrams"><a href="#Sherlock-and-Anagrams" class="headerlink" title="Sherlock and Anagrams"></a><a target="_blank" rel="noopener" href="https://www.hackerrank.com/challenges/sherlock-and-anagrams">Sherlock and Anagrams</a></h3><p>一道中等难度的题目,最初采用将字符串都拆解成他们的不同字串的方法，结果超时了，想想也是，如果是100个字母长度的字符串，那么结果就是2<sup>100</sup>,不超时才怪。</p>
<pre><code class="python">from collections import Counter

def checkAnag(a,b):
    if Counter(a) == Counter(b):
        return True
    
def sherlockAndAnagrams(s):
    count = 0
    s1 = &quot;&quot;.join(reversed(s))
    sub1 =[s1[i:i+x+1] for i in range(len(s1)) for x in range(len(s1)-i)]
    if s1 in sub1:
        sub1.remove(s1)
    for i in range(len(sub1)):
        for j in range(i+1,len(sub1)):
            if checkAnag(sub1[i],sub1[j]):
                count += 1
    return count
</code></pre>
<h2 id="与其对其中的每一个字母进行计数，还不如将所有的字母都按顺序排列一遍，然后再比较最后的两个序列是否相同，此思路的实现代码如下python-def-sherlockAndAnagrams-s-count-0-dict-n-len-s-for-i-in-range-n-for-j-in-range-n-i-sub-39-39-join-sorted-s-j-j-i-1-try-dict-sub-1-except-dict-sub-1-for-i-in-dict-count-dict-i-dict-i-1-2-return-count"><a href="#与其对其中的每一个字母进行计数，还不如将所有的字母都按顺序排列一遍，然后再比较最后的两个序列是否相同，此思路的实现代码如下python-def-sherlockAndAnagrams-s-count-0-dict-n-len-s-for-i-in-range-n-for-j-in-range-n-i-sub-39-39-join-sorted-s-j-j-i-1-try-dict-sub-1-except-dict-sub-1-for-i-in-dict-count-dict-i-dict-i-1-2-return-count" class="headerlink" title="与其对其中的每一个字母进行计数，还不如将所有的字母都按顺序排列一遍，然后再比较最后的两个序列是否相同，此思路的实现代码如下python def sherlockAndAnagrams(s):     count=0     dict={}     n=len(s)     for i in range(n):         for j in range(n-i):             sub=&#39;&#39;.join(sorted(s[j:j+i+1]))             try:                 dict[sub]+=1             except:                 dict[sub]=1     for i in dict:         count+=dict[i]*(dict[i]-1)//2     return count "></a>与其对其中的每一个字母进行计数，还不如将所有的字母都按顺序排列一遍，然后再比较最后的两个序列是否相同，此思路的实现代码如下<br><code>python def sherlockAndAnagrams(s):     count=0     dict=&#123;&#125;     n=len(s)     for i in range(n):         for j in range(n-i):             sub=&#39;&#39;.join(sorted(s[j:j+i+1]))             try:                 dict[sub]+=1             except:                 dict[sub]=1     for i in dict:         count+=dict[i]*(dict[i]-1)//2     return count </code></h2><h3 id="Count-Triplets"><a href="#Count-Triplets" class="headerlink" title="Count Triplets"></a><a target="_blank" rel="noopener" href="https://www.hackerrank.com/challenges/count-triplets-1">Count Triplets</a></h3><p>对三个数进行r倍组合，1为特殊情况，我直接用了组合计算，不过代码出现了超时，再研究研究哪里出了问题</p>
<pre><code class="python">from collections import Counter
from itertools import combinations
# Complete the countTriplets function below.
def combinationResult(num):
    i = 0
    for combination in combinations(range(num),3):
        i += 1
    return i 
def countTriplets(arr, r):
    sum = 0
    square = r**2
    countNum = Counter(arr)
    if r == 1:
        for v in countNum:
            if(countNum[v]&gt;2):
                sum += combinationResult(countNum[v])
        return sum
    sortSet = list(sorted(set(arr)))
    firstLimit = sortSet[len(sortSet)-1]/square
    for x in sortSet:
        if x &gt; firstLimit:
            break
        if x*r in sortSet and x*square in sortSet:
            sum += countNum[x]*countNum[x*r]*countNum[x*square]
    
    return sum
</code></pre>
<p>关于组合数的计算，参见<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41947081/article/details/80740756">python计算组合数的两种实现方法</a><br>经过对两种方法(直接进行组合与笛卡尔乘积)的比对，得出直接利用combinations来计算更加迅速一些,以下为比较代码：</p>
<pre><code class="python">import math
import itertools
import time
from itertools import combinations

unique = [1, 2, 3, 4, 5, 56, 78, 23]
time1 = time.time()
for j in range(1000000):
    i = 0
    for combination in combinations(unique, 2):
        i += 1

time2 = time.time()

for j in range(1000000):
    d = 0
    uniques = [unique, unique]
    for combination in itertools.product(*uniques):
        d += 1
time3 = time.time()
print(&quot;time 2-1 = &quot;+str(time2-time1), &quot;time 3-1 = &quot;+str(time3-time2))
#time 2-1 = 3.7130393981933594 time 3-1 = 7.952743053436279
</code></pre>
<p>为了将这道题解决，我看了一下出题者的解释，在出题者的hint中提到本题是能够达到O(n)的复杂度的，反观一下自己，虽然自己并没有写什么循环，不过的话在循环里的if语句中用到了两个in，基本算是O(n<sup>3</sup>)的复杂度了。<br>按照作者的意思，作者进行个对arr的遍历，建立两个字典，假设三元组为(A，B，C)，两个字典分别是指对于B来说A已经存在了，以及对于C来说（A，B）的组合已经准备好了。<br>每个字典里面放的并不是实值，而是对于未来三元组的一个可能性的预测，在遍历每个A的同时让B与C的线性空间不断减小，是一个非常有意思的解决思路。以下是它的python代码。</p>
<pre><code class="python">def countTriplets(arr, r):
    r2 = Counter()
    r3 = Counter()
    count = 0
    
    for v in arr:
        if v in r3:
            count += r3[v]
        
        if v in r2:
            r3[v*r] += r2[v]
        
        r2[v*r] += 1

    return count
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/spring/" title="Spring, Spring Boot, Restful, Docker"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Spring, Spring Boot, Restful, Docker</span></a><a class="button is-default" href="/list_hr/" title="Hackerrank Arrays 解题记录"><span class="has-text-weight-semibold">Next: Hackerrank Arrays 解题记录</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><script src="/js/post.js"></script></body></html>